##
# @description Services (customizations for production)
# @author      C. M. de Picciotto <d3p1@d3p1.dev> (https://d3p1.dev/)
# @note        This file is intended to be used as an extension of the 
#              main/primary `docker-compose.yml`, i.e.:               
#              `docker compose \ 
#               -f docker-compose.yml \ 
#               -f docker-compose.prod.yml \
#               up -d`
# @note        Add Traefik configuration to be able to generate platform 
#              certificates using Let's Encrypt
# @note        Send arguments to `web` service to build production image.
#              The most important one is `BUILD_CMD`
#              because these is the one that build app but it is not present
#              at build time (just at runtime)
# @note        For the `web` service, is set the `pull_policy` to `always`,
#              to ensure that the latest image is always used.
#              Additionally, we set its tag to `latest` for the same reason
# @note        The current approach creates a volume to share source code
#              between the services `web` and `cli`.
#              This does not follow the best practice of being each container
#              a self-contained unit. However, for now, it is considered
#              that this approach has more advantages than
#              creating an image for each service (so each
#              container is a self-contained unit). Sharing the source code
#              with a named volume allows us to avoid having
#              to maintain multiple images for each service. Additionally,
#              it allows us to have a different volume for each release, which
#              could be useful for rollbacks
# @note        The named volume that shares the source code uses a
#              `RELEASE_ID` so it is created a new one for each release.
#              This is necessary because the new image content of the `web`
#              service will be overridden by old named volume content.
#              This is why we should init this environment with
#              a command similar to: `RELEASE_ID="<release-id>" docker compose up -d`
##
services:
  traefik:
    volumes:
      - ./services/traefik/etc/acme.json:/etc/traefik/acme.json
    environment:
      - TRAEFIK_CERTIFICATESRESOLVERS_LE-HTTP_ACME_EMAIL=${BASE_USER_EMAIL}
      - TRAEFIK_CERTIFICATESRESOLVERS_LE-HTTP_ACME_STORAGE=/etc/traefik/acme.json
      - TRAEFIK_CERTIFICATESRESOLVERS_LE-HTTP_ACME_HTTPCHALLENGE_ENTRYPOINT=web

  web:
    image: ${BASE_WEB_IMAGE_NAME}:latest
    pull_policy: always
    build:
      context: ${BASE_HOST_DOC_ROOT_DIR}
      args:
        - BASE_NODE_VERSION=${BASE_NODE_VERSION}
        - BASE_BUN_VERSION=${BASE_BUN_VERSION}
        - BASE_REMOTE_DOC_ROOT_DIR=${BASE_REMOTE_DOC_ROOT_DIR}
        - BASE_JS_COMMAND_RUNNER=${BASE_JS_COMMAND_RUNNER}
        - BUILD_CMD=${BASE_BUILD_CMD}
    volumes:
      - docroot_${RELEASE_ID:-0.0.0}:${BASE_REMOTE_DOC_ROOT_DIR}
    environment:
      - NODE_ENV=production
    labels:
      - traefik.http.routers.https-next.tls.certresolver=le-http

  cli:
    volumes:
      - docroot_${RELEASE_ID:-0.0.0}:${BASE_REMOTE_DOC_ROOT_DIR}

volumes:
  docroot_${RELEASE_ID:-0.0.0}: